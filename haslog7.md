# 七日目

京都に帰る電車の中で。

(しばらくHaskellする時間とれなくなりそうだけど許して

### 5.4

- ラムダ式。Android で書かせてくれ…
- 引数を受け取って、その次に値を返す感じですね。
  - これで前までできないのかなって言ってたやつもできるようになりそう。
  - カリー化で十分なとこはカリー化で。
  - 試しに `map (*3 + 1) [1,3,0,3]`ってやったらできなかった。
    - `map (\x -> x * 3 + 1) [1,3,0,3]` でできる。
  - `zipWith (\a b -> (a,b)) [1,2,3] [3,4,5,5] => [(1,3), (2,4), (3,5)]
- やっぱラムダ式は楽でいいなあ。これできないんだろうかっていうのが大体できるようになってて最高って感じがする。`
- ラムダ式をそのまま変数にすることもできるのか（しないけど
- flip そんなに使うことはなさそう。

### 5.5

- (x:xs) は便利ですよね
- 折り紙のイラストあるけど海外でも折り紙ってするんだろうか。てかこれ鶴だし。
- 再帰、リストを一つの要素から作る場合は値を生成してどんどん連結していく感覚で、リストから一つの要素にする場合は値をパターンマッチで分割してリストの要素をどんどん一つの値に押し込めていくという感じだ。

- `fold` 系は 処理、初期値(アキュムレータ)、対象とするリストの順番。
  - まあこれだと再帰でシュッと書けそう。
  - `nonySum (x:xs) = x + nonySum xs` 的な感じ。
- 引数省略みたいなこわいこともできるのかぁ。
  - scala のコードみてもわけわからんかったけどアレも省略されてるんかな

- `foldr` は `foldl` 渡される変数のの順番が逆
- 右から畳み込むの、リストを生成するのには便利そう。
- `reverse` 実装したら `flip` 便利だと気づいた。
- というか畳み込みってただの `for`みたいなもんでは?
  - python の `for line in f: ~` 的な

- `foldr` でも無限リストに対応するの不思議だと思ったけど、遅延評価だから最後のが引き出されるまでにそれまでも評価するので途中で終わるやつなら対応出来るってことかな。
  - カリー化とかそんな感じな気がしてきた？
- 遅延評価、`sum` とかだと計算数を少なくする代わりにメモリとか犠牲になりそう。
- `scan` はアッハイって感じだった
- `takeWhile (<1000) (scanl1 (+) (map (^2) [1..])` だと、`scanl1` から出される数値を `takeWhile` で検査してる。（`scanl1` から出されるのは無限リストで、ここでも遅延評価が生きてそう


# 感想

- 今まで Haskell に違和感あったの、関数につかう `=` なんだけどよく考えたら関数に変数をあてはめたときの値だから等価であってるじゃんと気づいた。
- 今のところ、おお短くかけていいねえという感想。
  - javaは冗長と言われてるし…
- だんだん難しくなってきた気がする。一節にかかる時間も長くなった。

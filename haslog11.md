# 十一日目

お久しぶりです!! 台風一過。

### 7.3

```haskell
data Person = Person String String Int Float String String
```

- クラスのメンバ変数っぽい。
  - もしくはコンストラクタみたいな
  - 変数に名前つけられないんかな...

> やれやれ。こんなの書いてても全然楽しくないっすね!

> うそだよー、ありますよ! ハッハッハッ!
  - 雑で良い。

- レコードを用いればメンバ変数的なソレに名前つけれてる(ようなもん(怒られそう))
  - あとは型の表示が見やすいし、順番も気にしなくて良い
    - フィールド名を指定しない方法ももちろんできる
    - obj-Cとかswiftとか思い出した
  - 関数を生み出してるけど関数の名前被りそうで心配
  - 実際に同じ名前を持った型をもう一つ作ったら怒られた

### 7.4
- `::` で型を詳しく指定
  - 型引数、リストで散々やったのでそんなもんかという感想
- Haskellはケツコンマを許さない
  - この本では要素の前に `,` つけることでいい感じにしてるけどそういう文化なのかな

```haskell
data TestP = TestP { testName :: String
     , testFlavor :: String }
```

```haskell
data Car a b c = Car { company :: a,
     model :: b,
     year :: c
     } deriving (Show)
```

みたいにして（`TestP` は `Show` できないのがミソ）ghciで、

```haskell
let a = Car "a" "b" $ TestP "c" "d"
```

ってすると普通に通ったので、a,b,cが `Show` できるかどうかというのは見てなさそう。もちろん ghci に出力するタイミングで死ぬけど。これ安全なんだろうか...

- 調べてみたらそもそも `deriving` は一部の型クラスにしか使えないらしい。
  - コンパイラによって違うとか書いてあるしよくわからん ( http://stackoverflow.com/questions/3864647/how-does-deriving-work-in-haskell )

- まあできればやるみたいなそういう文脈なのかな、リストとか考えてもそういうことなのだろう
  - データ宣言には型クラスをつくらず、関数で制限するという文脈らしい。
    - 要するに関数側で型制約をつけましょうという感じかな

- とにかくジェネリック
- `Vector a` における a は型引数


### 7.5
- さっき調べてたやつじゃん。
- `read` は `show` の逆
- `True` と `False` って大小比較できたんだ
- `Just 3 > Just 2` はいけるけど `Just 3 > 2` は無理なんですねえ
  - どちらかがどちらかに変換すればよさそう

```haskell
data TwoItems = Hoge | Piyo
     deriving (Eq, Ord, Show, Read, Bounded, Enum)
```

して `succ Piyo` すると怒られる。どうやらこれだけじゃループは無理そう。独自に書いたらよさそう。

### 7.6
- 型シノニム。タプルとか適当に型シノニム使っていくと便利そう
- 関数内限定で型シノニム使えるとよさそう
- `Either` よくわからん...
  - エラー情報を入れることも出来るみたいなざっくりした理解
  - タプルやクラスと何が違うんだかわからん、特化したものと捉えてるけど

## 感想

- 久しぶりだけどやっぱ楽しいですね
- 最近とにかく遅延評価してくれという気持ちでいる
- 型クラスのあたりは大体わかってきた気がする、文法を学んでいる感覚
- これぐらい自分で作ればいいじゃんみたいなものが多く用意されてるイメージ。
